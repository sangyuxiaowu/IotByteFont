using System.IO;
using System.Text;
using SkiaSharp;
using CommandLine;

Parser.Default.ParseArguments<Options>(args)
    .WithParsed<Options>(o =>
    {
        // 判断字符设置是否存在
        if(string.IsNullOrEmpty(o.Char))
        {
            Console.WriteLine("Char is null.");
            return;
        }

        // 判断字体设置是否存在
        if(string.IsNullOrEmpty(o.Font))
        {
            o.Font = "Microsoft YaHei UI";
        }

        // 开启调试模式，创建临时文件夹
        if(o.Debug)
        {
            Directory.CreateDirectory("tmp");
        }

        // 字体宽度和长度处理
        if(o.Width == 0)
        {
            o.Width = o.Size;
        }
        if(o.Width * 8 % o.Size != 0)
        {
            Console.WriteLine("Width * 8 % Size != 0");
            return;
        }

        // 获取要生成的字符
        var characters = File.Exists(o.Char) ? File.ReadAllText(o.Char): o.Char;

        //去除空白字符和控制字符和重复字符
        characters = new string(characters.Where(c => !char.IsWhiteSpace(c) && !char.IsControl(c)).Distinct().ToArray());

        //开头加入一个空白字符
        characters = " " + characters;

        // 打开输出文件开始输出
        using var output = File.CreateText($"{o.Name}.cs");
        // 输出文件头
        output.WriteLine($@"// Path: {o.Name}.cs");
        output.WriteLine($@"// FromFamily: {Path.GetFileNameWithoutExtension(o.Font)}");
        output.WriteLine($@"// Date: {DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss")}");
        output.WriteLine($@"// This file is generated by IotByteFont.");
        output.WriteLine($@"// https://github.com/sangyuxiaowu/IotByteFont");
        output.WriteLine($@"// System.Collections package is required.");
        output.WriteLine();
        output.WriteLine($@"using Iot.Device.Ssd13xx;");
        output.WriteLine($@"using System;");
        output.WriteLine($@"using System.Collections;");
        output.WriteLine();
        output.WriteLine($@"namespace Iot.ByteFont");
        output.WriteLine($@"{{");
        output.WriteLine($@"    /// <summary>");
        output.WriteLine($@"    /// {o.Width}x{o.Size} Font, generated by IotByteFont.");
        output.WriteLine($@"    /// </summary>");
        output.WriteLine($@"    public class {o.Name} : IFont");
        output.WriteLine($@"    {{");
        output.WriteLine($@"        /// <summary>");
        output.WriteLine($@"        /// font data.");
        output.WriteLine($@"        /// </summary>");
        output.WriteLine($@"        public static readonly Hashtable _fontTable = new Hashtable()");
        output.WriteLine($@"        {{");

        foreach (char character in characters)
        {
            // 生成字符
            var codestring = ConvertFontToBitmap(o.Font, character, o.Size, o.Width, o.YOffset, o.Threshold,o.Debug);
            // 输出字符
            output.WriteLine($@"            {{{(int)character}, new byte[]{{{codestring}}}}}, // {character}");
        }

        output.WriteLine($@"        }};");
        output.WriteLine($@"");
        output.WriteLine($@"        public override byte Width {{ get => {o.Width}; }}");
        output.WriteLine($@"        public override byte Height {{ get => {o.Size}; }}");
        output.WriteLine($@"        public override byte[] this[char character]
        {{
            get
            {{
                int charCode = (int)character;
                if (_fontTable.Contains(charCode))
                {{
                    return (byte[])_fontTable[charCode];
                }}
                else
                {{
                    return (byte[])_fontTable[32];
                }}
            }}
        }}");
        output.WriteLine($@"    }}");
        output.WriteLine($@"}}");


        // 如果开启了调试模式，将最终的位图保存为整个png文件
        // 位图为能容纳下所有字体位图的正方形
        if(o.Debug)
        {
            int sq_len = (int)Math.Ceiling(Math.Sqrt(characters.Length));
            int width = sq_len * o.Width;
            int height = sq_len * o.Size;
            var bitmap = new SKBitmap(width,height);
            var canvas = new SKCanvas(bitmap);
            canvas.Clear(SKColors.Black);
            int x = 0;
            int y = 0;
            foreach (char character in characters)
            {
                var fontBitmap = SKBitmap.Decode($@"tmp\{(int)character}.png");
                canvas.DrawBitmap(fontBitmap, x, y);
                x += o.Width;
                if(x >= width)
                {
                    x = 0;
                    y += o.Size;
                }
            }
            using (var image = SKImage.FromBitmap(bitmap))
            using (var data = image.Encode(SKEncodedImageFormat.Png, 100))
            using (var stream = File.OpenWrite($@"{o.Name}.png"))
            {
                data.SaveTo(stream);
            }
            // 删除临时文件夹
            Directory.Delete("tmp", true);
        }
        
    });


string ConvertFontToBitmap(string fontPath, char character, int size,int width, float yoffset = 0.75f,int Threshold=128, bool debug = false)
{
    // 创建一个SKTypeface实例
    var typeface = File.Exists(fontPath) ? SKTypeface.FromFile(fontPath): SKTypeface.FromFamilyName(fontPath);

    // 创建一个SKPaint实例
    var paint = new SKPaint
    {
        Typeface = typeface,
        TextSize = size,
        IsAntialias = false,
        TextAlign = SKTextAlign.Center,
        Color = SKColors.White,
    };

    // 判断字符是否能够容纳在指定的宽度内
    var textWidth = paint.MeasureText(character.ToString());
    var isfit = textWidth <= width;

    // 创建一个bitmap来容纳字符
    var bitmap = new SKBitmap(isfit?width:size,size);
    // 创建一个SKCanvas实例
    var canvas = new SKCanvas(bitmap);
    // 将canvas的背景填充为白色
    canvas.Clear(SKColors.Black);
    // 在bitmap上绘制字符
    canvas.DrawText(character.ToString(), (isfit?width:size)/2, size*yoffset, paint);

    // 若字符不能容纳在指定的宽度内，则将bitmap缩放到指定的宽度
    if(!isfit)
    {
        var scaledBitmap = new SKBitmap(width,size);
        bitmap.ScalePixels(scaledBitmap, SKFilterQuality.High);
        bitmap.Dispose();
        bitmap = scaledBitmap;
    }
    
    /* // 适合固定的字体
    List<string> hexData = new List<string>();
    for (int y = 0; y < bitmap.Height; y++)
    {
        for (int x = 0; x < bitmap.Width; x += 8)
        {
            int value = 0;
            for (int bit = 0; bit < 8; bit++)
            {
                SKColor color = bitmap.GetPixel(x + bit, y);
                // 将像素值二值化
                int binary = color.Red > 180 ? 1 : 0;
                // 将二值化的像素值组合成一个字节
                value |= binary << bit;
            }
            // 将二进制数据转换为16进制的数据
            hexData.Add("0x" + value.ToString("X2"));
        }
    }
    */
    List<string> hexData = new List<string>();
    List<int> binaryData = new List<int>();

    // 从左到右，从上到下读取像素并进行二值化
    for (int y = 0; y < bitmap.Height; y++)
    {
        for (int x = 0; x < bitmap.Width; x++)
        {
            SKColor color = bitmap.GetPixel(x, y);
            // 将像素值二值化
            int binary = color.Red > Threshold ? 1 : 0;
            bitmap.SetPixel(x, y, binary == 1 ? SKColors.White : SKColors.Black);
            binaryData.Add(binary);
        }
    }

    // 每8个像素生成一个16进制数
    for (int i = 0; i < binaryData.Count; i += 8)
    {
        int value = 0;
        for (int bit = 0; bit < 8; bit++)
        {
            value |= binaryData[i + bit] << bit;
        }
        // 将二进制数据转换为16进制的数据
        hexData.Add("0x" + value.ToString("X2"));
    }


    var csCode = string.Join(", ", hexData);

    // 输出调试信息
    if (debug)
    {
        Console.WriteLine($"char: {character}, code: {csCode}");
        // 将bitmap保存为png文件
        using (var image = SKImage.FromBitmap(bitmap))
        using (var data = image.Encode(SKEncodedImageFormat.Png, 100))
        using (var stream = File.OpenWrite($@"tmp\{(int)character}.png"))
        {
            data.SaveTo(stream);
        }
    }
    return csCode.ToString();
}